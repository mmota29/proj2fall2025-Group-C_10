-------------------------------------------------------------------------
-- Henry Duwe
-- Department of Electrical and Computer Engineering
-- Iowa State University
-------------------------------------------------------------------------
-- RISCV_Processor.vhd
-------------------------------------------------------------------------
-- Software-scheduled pipelined RISC-V processor (5-stage, no hazards)
-------------------------------------------------------------------------

library IEEE;
use IEEE.std_logic_1164.all;
use IEEE.numeric_std.all;

library work;
use work.RISCV_types.all;

entity RISCV_Processor is
  generic(N : integer := DATA_WIDTH);
  port(
    iCLK      : in std_logic;
    iRST      : in std_logic;
    iInstLd   : in std_logic;
    iInstAddr : in std_logic_vector(N-1 downto 0);
    iInstExt  : in std_logic_vector(N-1 downto 0);
    oALUOut   : out std_logic_vector(N-1 downto 0)
  );
end RISCV_Processor;

architecture structure of RISCV_Processor is

  -- Required data memory signals
  signal s_DMemWr   : std_logic;
  signal s_DMemAddr : std_logic_vector(N-1 downto 0);
  signal s_DMemData : std_logic_vector(N-1 downto 0);
  signal s_DMemOut  : std_logic_vector(N-1 downto 0);
 
  -- Required register file signals 
  signal s_RegWr     : std_logic;
  signal s_RegWrAddr : std_logic_vector(4 downto 0);
  signal s_RegWrData : std_logic_vector(N-1 downto 0);

  -- Required instruction memory signals
  signal s_IMemAddr     : std_logic_vector(N-1 downto 0); -- Do not assign directly, assign s_NextInstAddr
  signal s_NextInstAddr : std_logic_vector(N-1 downto 0);
  signal s_Inst         : std_logic_vector(N-1 downto 0);

  -- Required halt / overflow
  signal s_Halt : std_logic;
  signal s_Ovfl : std_logic;

  component mem is
    generic(ADDR_WIDTH : integer;
            DATA_WIDTH : integer);
    port(
      clk  : in std_logic;
      addr : in std_logic_vector((ADDR_WIDTH-1) downto 0);
      data : in std_logic_vector((DATA_WIDTH-1) downto 0);
      we   : in std_logic := '1';
      q    : out std_logic_vector((DATA_WIDTH -1) downto 0)
    );
  end component;

  -----------------------------------------------------------------------
  -- Additional components you already have:
  -----------------------------------------------------------------------
  component RegFile is
    port(
      clk      : in std_logic;
      rst      : in std_logic;
      en       : in std_logic;
      rs1_ad   : in std_logic_vector(4 downto 0);
      rs2_ad   : in std_logic_vector(4 downto 0);
      rd_ad    : in std_logic_vector(4 downto 0);
      rd_data  : in std_logic_vector(31 downto 0);
      rs1_data : out std_logic_vector(31 downto 0);
      rs2_data : out std_logic_vector(31 downto 0)
    );
  end component;

  component alu is
    port(
      A      : in  std_logic_vector(31 downto 0);
      B      : in  std_logic_vector(31 downto 0);
      ALUOp  : in  std_logic_vector(3 downto 0);
      Result : out std_logic_vector(31 downto 0);
      Zero   : out std_logic
    );
  end component;

  component control_unit is
    port(
      opcode   : in  std_logic_vector(6 downto 0);
      funct3   : in  std_logic_vector(2 downto 0);
      funct7   : in  std_logic_vector(6 downto 0);

      RegWrite : out std_logic;
      MemRead  : out std_logic;
      MemWrite : out std_logic;
      MemToReg : out std_logic_vector(1 downto 0);
      ALUOp    : out std_logic_vector(3 downto 0);
      ALUSrc   : out std_logic;
      Branch   : out std_logic;
      Jump     : out std_logic;
      Halt     : out std_logic
    );
  end component;

  component imm_gen is
    port(
      instr   : in  std_logic_vector(N-1 downto 0);
      imm_out : out std_logic_vector(N-1 downto 0)
    );
  end component;

  component IF_ID_reg is
    generic(N : integer := DATA_WIDTH);
    port(
      clk       : in  std_logic;
      rst       : in  std_logic;
      iPC_plus4 : in  std_logic_vector(N-1 downto 0);
      iInst     : in  std_logic_vector(N-1 downto 0);
      oPC_plus4 : out std_logic_vector(N-1 downto 0);
      oInst     : out std_logic_vector(N-1 downto 0)
    );
  end component;

  component ID_EX_reg is
    generic(N : integer := DATA_WIDTH);
    port(
      clk        : in  std_logic;
      rst        : in  std_logic;

      iPC_plus4  : in  std_logic_vector(N-1 downto 0);
      i_rs1_data : in  std_logic_vector(N-1 downto 0);
      i_rs2_data : in  std_logic_vector(N-1 downto 0);
      i_Imm      : in  std_logic_vector(N-1 downto 0);
      i_rs1      : in  std_logic_vector(4 downto 0);
      i_rs2      : in  std_logic_vector(4 downto 0);
      i_rd       : in  std_logic_vector(4 downto 0);

      i_RegWrite : in  std_logic;
      i_MemRead  : in  std_logic;
      i_MemWrite : in  std_logic;
      i_MemToReg : in  std_logic_vector(1 downto 0);
      i_ALUOp    : in  std_logic_vector(3 downto 0);
      i_ALUSrc   : in  std_logic;
      i_Branch   : in  std_logic;
      i_Jump     : in  std_logic;
      i_Halt     : in  std_logic;

      oPC_plus4  : out std_logic_vector(N-1 downto 0);
      o_rs1_data : out std_logic_vector(N-1 downto 0);
      o_rs2_data : out std_logic_vector(N-1 downto 0);
      o_Imm      : out std_logic_vector(N-1 downto 0);
      o_rs1      : out std_logic_vector(4 downto 0);
      o_rs2      : out std_logic_vector(4 downto 0);
      o_rd       : out std_logic_vector(4 downto 0);

      o_RegWrite : out std_logic;
      o_MemRead  : out std_logic;
      o_MemWrite : out std_logic;
      o_MemToReg : out std_logic_vector(1 downto 0);
      o_ALUOp    : out std_logic_vector(3 downto 0);
      o_ALUSrc   : out std_logic;
      o_Branch   : out std_logic;
      o_Jump     : out std_logic;
      o_Halt     : out std_logic
    );
  end component;

  component EX_MEM_reg is
    generic(N : integer := DATA_WIDTH);
    port(
      clk        : in  std_logic;
      rst        : in  std_logic;

      i_ALUOut   : in  std_logic_vector(N-1 downto 0);
      i_rs2_data : in  std_logic_vector(N-1 downto 0);
      i_rd       : in  std_logic_vector(4 downto 0);

      i_RegWrite : in  std_logic;
      i_MemRead  : in  std_logic;
      i_MemWrite : in  std_logic;
      i_MemToReg : in  std_logic_vector(1 downto 0);
      i_Halt     : in  std_logic;

      o_ALUOut   : out std_logic_vector(N-1 downto 0);
      o_rs2_data : out std_logic_vector(N-1 downto 0);
      o_rd       : out std_logic_vector(4 downto 0);

      o_RegWrite : out std_logic;
      o_MemRead  : out std_logic;
      o_MemWrite : out std_logic;
      o_MemToReg : out std_logic_vector(1 downto 0);
      o_Halt     : out std_logic
    );
  end component;

  component MEM_WB_reg is
    generic(N : integer := DATA_WIDTH);
    port(
      clk        : in  std_logic;
      rst        : in  std_logic;

      i_ALUOut   : in  std_logic_vector(N-1 downto 0);
      i_DMemOut  : in  std_logic_vector(N-1 downto 0);
      i_rd       : in  std_logic_vector(4 downto 0);

      i_RegWrite : in  std_logic;
      i_MemToReg : in  std_logic_vector(1 downto 0);
      i_Halt     : in  std_logic;

      o_ALUOut   : out std_logic_vector(N-1 downto 0);
      o_DMemOut  : out std_logic_vector(N-1 downto 0);
      o_rd       : out std_logic_vector(4 downto 0);

      o_RegWrite : out std_logic;
      o_MemToReg : out std_logic_vector(1 downto 0);
      o_Halt     : out std_logic
    );
  end component;

  -----------------------------------------------------------------------
  -- Pipeline and stage signals
  -----------------------------------------------------------------------

  -- PC / IF
  signal s_PC       : std_logic_vector(N-1 downto 0);
  signal s_PC_next  : std_logic_vector(N-1 downto 0);
  signal s_PC_plus4 : std_logic_vector(N-1 downto 0);

  -- IF/ID
  signal IFID_PC_plus4 : std_logic_vector(N-1 downto 0);
  signal IFID_Inst     : std_logic_vector(N-1 downto 0);

  -- ID stage decoding
  signal ID_PC_plus4 : std_logic_vector(N-1 downto 0);
  signal ID_Inst     : std_logic_vector(N-1 downto 0);
  signal ID_opcode   : std_logic_vector(6 downto 0);
  signal ID_funct3   : std_logic_vector(2 downto 0);
  signal ID_funct7   : std_logic_vector(6 downto 0);
  signal ID_rs1      : std_logic_vector(4 downto 0);
  signal ID_rs2      : std_logic_vector(4 downto 0);
  signal ID_rd       : std_logic_vector(4 downto 0);

  signal ID_rs1_data : std_logic_vector(N-1 downto 0);
  signal ID_rs2_data : std_logic_vector(N-1 downto 0);
  signal ID_Imm      : std_logic_vector(N-1 downto 0);

  -- ID control signals
  signal ID_RegWrite : std_logic;
  signal ID_MemRead  : std_logic;
  signal ID_MemWrite : std_logic;
  signal ID_MemToReg : std_logic_vector(1 downto 0);
  signal ID_ALUOp    : std_logic_vector(3 downto 0);
  signal ID_ALUSrc   : std_logic;
  signal ID_Branch   : std_logic;
  signal ID_Jump     : std_logic;
  signal ID_Halt     : std_logic;

  -- ID/EX
  signal IDEX_PC_plus4  : std_logic_vector(N-1 downto 0);
  signal IDEX_rs1_data  : std_logic_vector(N-1 downto 0);
  signal IDEX_rs2_data  : std_logic_vector(N-1 downto 0);
  signal IDEX_Imm       : std_logic_vector(N-1 downto 0);
  signal IDEX_rs1       : std_logic_vector(4 downto 0);
  signal IDEX_rs2       : std_logic_vector(4 downto 0);
  signal IDEX_rd        : std_logic_vector(4 downto 0);
  signal IDEX_RegWrite  : std_logic;
  signal IDEX_MemRead   : std_logic;
  signal IDEX_MemWrite  : std_logic;
  signal IDEX_MemToReg  : std_logic_vector(1 downto 0);
  signal IDEX_ALUOp     : std_logic_vector(3 downto 0);
  signal IDEX_ALUSrc    : std_logic;
  signal IDEX_Branch    : std_logic;
  signal IDEX_Jump      : std_logic;
  signal IDEX_Halt      : std_logic;

  -- ID stage extra signals for control flow
  signal ID_PC          : std_logic_vector(N-1 downto 0);  -- actual PC of ID instruction
  signal ID_branch_taken: std_logic;
  signal ID_branch_tgt  : std_logic_vector(N-1 downto 0);
  signal ID_jump_tgt    : std_logic_vector(N-1 downto 0);
  ID_PC_plus4 <= IFID_PC_plus4;
  ID_Inst     <= IFID_Inst;
  -- PC of instruction in ID (IFID latched PC+4, so subtract 4)
  ID_PC <= std_logic_vector(unsigned(ID_PC_plus4) - 4);
 -----------------------------------------------------------------------
  -- Branch condition logic (ID stage)
  -- Uses rs1/rs2 values and funct3.
  -----------------------------------------------------------------------
  process(ID_Branch, ID_funct3, ID_rs1_data, ID_rs2_data)
  begin
    ID_branch_taken <= '0';

    if ID_Branch = '1' then
      case ID_funct3 is
        when "000" =>  -- BEQ
          if ID_rs1_data = ID_rs2_data then
            ID_branch_taken <= '1';
          end if;

        when "001" =>  -- BNE
          if ID_rs1_data /= ID_rs2_data then
            ID_branch_taken <= '1';
          end if;

        -- extend here for BLT/BGE/BLTU/BGEU if you implement them

        when others =>
          ID_branch_taken <= '0';
      end case;
    end if;
  end process;
  -----------------------------------------------------------------------
  -- Branch / Jump targets (ID stage)
  -- imm_gen is assumed to already have done the right shifting/sign-extend
  -----------------------------------------------------------------------
  -- Branch target: PC + imm
  ID_branch_tgt <= std_logic_vector(unsigned(ID_PC) + unsigned(ID_Imm));

  -- Jump target:
  --   JAL  : PC + imm
  --   JALR : (rs1 + imm) with bit 0 forced to 0
  -- We reuse ID_branch_tgt for JAL (same formula PC+imm)
  -- and compute a separate target for JALR
  signal_jalr_tmp: block
    signal jalr_sum : std_logic_vector(N-1 downto 0);
  begin
    jalr_sum <= std_logic_vector(unsigned(ID_rs1_data) + unsigned(ID_Imm));
    ID_jump_tgt <= jalr_sum(N-1 downto 1) & '0';  -- force LSB to 0
  end block;




  -- EX stage
  signal EX_ALU_inB  : std_logic_vector(N-1 downto 0);
  signal EX_ALUOut   : std_logic_vector(N-1 downto 0);
  signal EX_Zero     : std_logic;
  signal EX_branch_tgt : std_logic_vector(N-1 downto 0);


  -- EX/MEM
  signal EXMEM_ALUOut   : std_logic_vector(N-1 downto 0);
  signal EXMEM_rs2_data : std_logic_vector(N-1 downto 0);
  signal EXMEM_rd       : std_logic_vector(4 downto 0);
  signal EXMEM_RegWrite : std_logic;
  signal EXMEM_MemRead  : std_logic;
  signal EXMEM_MemWrite : std_logic;
  signal EXMEM_MemToReg : std_logic_vector(1 downto 0);
  signal EXMEM_Halt     : std_logic;

  -- MEM/WB
  signal MEMWB_ALUOut   : std_logic_vector(N-1 downto 0);
  signal MEMWB_DMemOut  : std_logic_vector(N-1 downto 0);
  signal MEMWB_rd       : std_logic_vector(4 downto 0);
  signal MEMWB_RegWrite : std_logic;
  signal MEMWB_MemToReg : std_logic_vector(1 downto 0);
  signal MEMWB_Halt     : std_logic;

  -- WB mux
  signal MEMWB_WriteData : std_logic_vector(N-1 downto 0);

begin

  -----------------------------------------------------------------------
  -- Instruction memory address mux (given in skeleton)
  -----------------------------------------------------------------------
  s_NextInstAddr <= s_PC;

  with iInstLd select
    s_IMemAddr <= s_NextInstAddr when '0',
                  iInstAddr      when others;

  IMem : mem
    generic map(ADDR_WIDTH => ADDR_WIDTH,
                DATA_WIDTH => N)
    port map(
      clk  => iCLK,
      addr => s_IMemAddr(11 downto 2),
      data => iInstExt,
      we   => iInstLd,
      q    => s_Inst
    );
  
  DMem : mem
    generic map(ADDR_WIDTH => ADDR_WIDTH,
                DATA_WIDTH => N)
    port map(
      clk  => iCLK,
      addr => s_DMemAddr(11 downto 2),
      data => s_DMemData,
      we   => s_DMemWr,
      q    => s_DMemOut
    );

  -----------------------------------------------------------------------
  -- PC register & PC+4 (IF stage)
  -----------------------------------------------------------------------
  process(iCLK)
  begin
    if rising_edge(iCLK) then
      if iRST = '1' then
        s_PC <= (others => '0');  -- could be x"00000100" if desired
      else
        s_PC <= s_PC_next;
      end if;
    end if;
  end process;

  s_PC_plus4 <= std_logic_vector(unsigned(s_PC) + 4);

   -----------------------------------------------------------------------
  -- PC next logic: handles PC+4, branches, JAL, JALR
  -- Branch/JAL/JALR decisions are made in ID.
  -----------------------------------------------------------------------
  process(s_PC_plus4, ID_PC, ID_branch_tgt, ID_jump_tgt,
          ID_branch_taken, ID_Jump, ID_opcode, ID_Halt)
  begin
    -- Default: fall-through
    s_PC_next <= s_PC_plus4;

    -- Halt: you can also just let PC keep moving;
    -- test framework uses s_Halt, not PC. This is optional.
    if ID_Halt = '1' then
      s_PC_next <= s_PC_next;  -- hold PC (no change)
    
    -- Jumps (JAL / JALR)
    elsif ID_Jump = '1' then
      -- opcode 1101111 = JAL
      if ID_opcode = "1101111" then
        s_PC_next <= ID_branch_tgt;   -- PC + imm
      -- opcode 1100111 = JALR
      elsif ID_opcode = "1100111" then
        s_PC_next <= ID_jump_tgt;     -- (rs1 + imm) & ~1
      else
        s_PC_next <= s_PC_plus4;
      end if;

    -- Conditional branch
    elsif ID_branch_taken = '1' then
      s_PC_next <= ID_branch_tgt;     -- branch target

    -- else: keep default PC+4
    end if;
  end process;


  -----------------------------------------------------------------------
  -- IF/ID pipeline register
  -----------------------------------------------------------------------
  U_IFID : IF_ID_reg
    generic map(N => N)
    port map(
      clk       => iCLK,
      rst       => iRST,
      iPC_plus4 => s_PC_plus4,
      iInst     => s_Inst,
      oPC_plus4 => IFID_PC_plus4,
      oInst     => IFID_Inst
    );

  -----------------------------------------------------------------------
  -- ID stage: decode fields
  -----------------------------------------------------------------------
  ID_PC_plus4 <= IFID_PC_plus4;
  ID_Inst     <= IFID_Inst;

  ID_opcode <= ID_Inst(6 downto 0);
  ID_rd     <= ID_Inst(11 downto 7);
  ID_funct3 <= ID_Inst(14 downto 12);
  ID_rs1    <= ID_Inst(19 downto 15);
  ID_rs2    <= ID_Inst(24 downto 20);
  ID_funct7 <= ID_Inst(31 downto 25);

  -----------------------------------------------------------------------
  -- Register file
  -----------------------------------------------------------------------
  U_REGFILE : RegFile
    port map(
      clk      => iCLK,
      rst      => iRST,
      en       => s_RegWr,
      rs1_ad   => ID_rs1,
      rs2_ad   => ID_rs2,
      rd_ad    => s_RegWrAddr,
      rd_data  => s_RegWrData,
      rs1_data => ID_rs1_data,
      rs2_data => ID_rs2_data
    );

  -----------------------------------------------------------------------
  -- Immediate generator
  -----------------------------------------------------------------------
  U_IMM : imm_gen
    port map(
      instr   => ID_Inst,
      imm_out => ID_Imm
    );

  -----------------------------------------------------------------------
  -- Control unit
  -----------------------------------------------------------------------
  U_CTRL : control_unit
    port map(
      opcode   => ID_opcode,
      funct3   => ID_funct3,
      funct7   => ID_funct7,
      RegWrite => ID_RegWrite,
      MemRead  => ID_MemRead,
      MemWrite => ID_MemWrite,
      MemToReg => ID_MemToReg,
      ALUOp    => ID_ALUOp,
      ALUSrc   => ID_ALUSrc,
      Branch   => ID_Branch,
      Jump     => ID_Jump,
      Halt     => ID_Halt
    );

  -----------------------------------------------------------------------
  -- ID/EX pipeline register
  -----------------------------------------------------------------------
  U_IDEX : ID_EX_reg
    generic map(N => N)
    port map(
      clk        => iCLK,
      rst        => iRST,

      iPC_plus4  => ID_PC_plus4,
      i_rs1_data => ID_rs1_data,
      i_rs2_data => ID_rs2_data,
      i_Imm      => ID_Imm,
      i_rs1      => ID_rs1,
      i_rs2      => ID_rs2,
      i_rd       => ID_rd,

      i_RegWrite => ID_RegWrite,
      i_MemRead  => ID_MemRead,
      i_MemWrite => ID_MemWrite,
      i_MemToReg => ID_MemToReg,
      i_ALUOp    => ID_ALUOp,
      i_ALUSrc   => ID_ALUSrc,
      i_Branch   => ID_Branch,
      i_Jump     => ID_Jump,
      i_Halt     => ID_Halt,

      oPC_plus4  => IDEX_PC_plus4,
      o_rs1_data => IDEX_rs1_data,
      o_rs2_data => IDEX_rs2_data,
      o_Imm      => IDEX_Imm,
      o_rs1      => IDEX_rs1,
      o_rs2      => IDEX_rs2,
      o_rd       => IDEX_rd,

      o_RegWrite => IDEX_RegWrite,
      o_MemRead  => IDEX_MemRead,
      o_MemWrite => IDEX_MemWrite,
      o_MemToReg => IDEX_MemToReg,
      o_ALUOp    => IDEX_ALUOp,
      o_ALUSrc   => IDEX_ALUSrc,
      o_Branch   => IDEX_Branch,
      o_Jump     => IDEX_Jump,
      o_Halt     => IDEX_Halt
    );

  -----------------------------------------------------------------------
  -- EX stage
  -----------------------------------------------------------------------
  -- ALU B input (imm vs rs2)
  EX_ALU_inB <= IDEX_Imm when IDEX_ALUSrc = '1' else IDEX_rs2_data;

  U_ALU : alu
    port map(
      A      => IDEX_rs1_data,
      B      => EX_ALU_inB,
      ALUOp  => IDEX_ALUOp,
      Result => EX_ALUOut,
      Zero   => EX_Zero
    );

  -- Branch target (PC+4 + imm, for example)
  EX_branch_tgt <= std_logic_vector(unsigned(IDEX_PC_plus4) + unsigned(IDEX_Imm));

  -----------------------------------------------------------------------
  -- EX/MEM pipeline register
  -----------------------------------------------------------------------
  U_EXMEM : EX_MEM_reg
    generic map(N => N)
    port map(
      clk        => iCLK,
      rst        => iRST,

      i_ALUOut   => EX_ALUOut,
      i_rs2_data => IDEX_rs2_data,
      i_rd       => IDEX_rd,

      i_RegWrite => IDEX_RegWrite,
      i_MemRead  => IDEX_MemRead,
      i_MemWrite => IDEX_MemWrite,
      i_MemToReg => IDEX_MemToReg,
      i_Halt     => IDEX_Halt,

      o_ALUOut   => EXMEM_ALUOut,
      o_rs2_data => EXMEM_rs2_data,
      o_rd       => EXMEM_rd,

      o_RegWrite => EXMEM_RegWrite,
      o_MemRead  => EXMEM_MemRead,
      o_MemWrite => EXMEM_MemWrite,
      o_MemToReg => EXMEM_MemToReg,
      o_Halt     => EXMEM_Halt
    );

  -----------------------------------------------------------------------
  -- MEM stage
  -----------------------------------------------------------------------
  s_DMemAddr <= EXMEM_ALUOut;
  s_DMemData <= EXMEM_rs2_data;
  s_DMemWr   <= EXMEM_MemWrite;

  -----------------------------------------------------------------------
  -- MEM/WB pipeline register
  -----------------------------------------------------------------------
  U_MEMWB : MEM_WB_reg
    generic map(N => N)
    port map(
      clk        => iCLK,
      rst        => iRST,

      i_ALUOut   => EXMEM_ALUOut,
      i_DMemOut  => s_DMemOut,
      i_rd       => EXMEM_rd,

      i_RegWrite => EXMEM_RegWrite,
      i_MemToReg => EXMEM_MemToReg,
      i_Halt     => EXMEM_Halt,

      o_ALUOut   => MEMWB_ALUOut,
      o_DMemOut  => MEMWB_DMemOut,
      o_rd       => MEMWB_rd,

      o_RegWrite => MEMWB_RegWrite,
      o_MemToReg => MEMWB_MemToReg,
      o_Halt     => MEMWB_Halt
    );

  -----------------------------------------------------------------------
  -- WB stage
  -----------------------------------------------------------------------
  -- Simple MemToReg: 00 = ALU, 01 = Mem (extend if you have PC+4)
  MEMWB_WriteData <= MEMWB_DMemOut when MEMWB_MemToReg = "01"
                     else MEMWB_ALUOut;

  s_RegWr     <= MEMWB_RegWrite;
  s_RegWrAddr <= MEMWB_rd;
  s_RegWrData <= MEMWB_WriteData;

  -----------------------------------------------------------------------
  -- Required status outputs
  -----------------------------------------------------------------------
  s_Halt <= MEMWB_Halt;      -- halt active at WB stage
  s_Ovfl <= '0';             -- TODO: hook to ALU overflow if you add it

  -- Hook ALU output so synthesis keeps the logic
  oALUOut <= EXMEM_ALUOut;   -- or MEMWB_ALUOut, either is OK

end architecture structure;
